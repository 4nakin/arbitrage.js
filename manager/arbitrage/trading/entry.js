/**
 * @since 03.01.2018
 * @author Skurishin Vladislav
 */
const moment = require("moment");
const TradingUtils = require("../utils.js");
const Spread = require("../../../models/spread");
const History = require("../../../models/history");
const TrailingManager = require("./trailing");
const logger = require("../../../utils/telegraf")(module);

class Entry {
  /**
   * Check market on entry. If spread > spreadEntry, then enter market.
   * @param exLong long exchange №1
   * @param exShort short exchange №2
   * @param pair currency pair
   */
  static async check ({exShort, exLong, pair}) {
    const {pairName} = pair;
    const tLong = exLong.tickers[pairName];
    const tShort = exShort.tickers[pairName];
    const bid = tShort.bid;
    const ask = tLong.ask;

    if (!ask && !bid) {
      return false;
    }

    const spread = (bid - ask) / ask;

    logger.info(`[${exShort.id} - ${exLong.id}] spread entry for ${pairName}: ${spread}`);

    if (TradingUtils.STATISTICS) {
      await Spread.create({
        spread,
        pairName,
        exShort,
        exLong
      });
      await History.create({
        spread,
        pairName,
        exShort,
        exLong
      });
      return false;
    }

    if (spread > 0) {
      logger.path(`Positive spread for [${exShort.id} - ${exLong.id}] and pair ${pairName}: ${spread.toFixed(
        4)}.`);
    }

    if (TrailingManager.entry({
        shortId: exShort.id,
        longId:  exLong.id,
        spread,
        pairName
      })) {
      const longFee = exLong.markets[pairName].taker;
      const shortFee = exShort.markets[pairName].taker;
      return {
        exShort:      exShort,
        exLong:       exLong,
        pair:         pair,
        priceLongIn:  ask,
        priceShortIn: bid,
        exitTarget:   spread - TradingUtils.SPREAD_TARGET - 2.0 * (longFee + shortFee)
      };
    }
  }

  /**
   * Start market entry.
   * @param entryInfo entry info
   * @param exposure exposure
   * @return {Promise.<boolean>}
   */
  static async start ({entryInfo, exposure}) {
    const {
      exLong,
      exShort,
      priceLongIn,
      priceShortIn,
      pair
    } = entryInfo;

    const {pairName} = pair;

    if (!exposure) {
      return false;
    }

    // Checks the volumes and, based on that, computes the limit prices
    // that will be sent to the exchanges
    const volumeLong = exposure / exLong.tickers[pairName].ask;
    const volumeShort = exposure / exShort.tickers[pairName].bid;

    const limPriceLong = await TradingUtils.getLimitPrice(exLong, volumeLong, "asks", pairName);
    const limPriceShort = await TradingUtils.getLimitPrice(exShort, volumeShort, "bids", pairName);

    if (!limPriceLong || !limPriceShort) {
      logger.warn(
        "Opportunity found, but error with the order books (limit price is null). Trade canceled.");
      return false;
    }

    // The maximum difference between the target
    // limit price and the computed limit price of an order.
    // That is the price generated by looking at the current liquidity in
    // the order books. If the difference is greater than liquidityDelta}
    // then no trades will be generated because there is not enough
    // liquidity (risk of slippage)
    if (limPriceLong - priceLongIn > TradingUtils.LIQUIDITY_DELTA
        || priceShortIn - limPriceShort > TradingUtils.LIQUIDITY_DELTA) {
      logger.warn("Opportunity found, but not enough liquidity. Trade canceled.");
      return false;
    }

    // We are in market now, meaning we have positions on leg1 (the hedged on)
    // We store the details of that first trade into the entryInfo structure.
    entryInfo.entryTime = moment();
    entryInfo.priceLongIn = limPriceLong;
    entryInfo.priceShortIn = limPriceShort;
    entryInfo.volumeLong = volumeLong;
    entryInfo.volumeShort = volumeShort;

    // TODO needs a limits check.
    // If limit > volume then exception occurs
    // and short exchange doesn't place order.
    if (!TradingUtils.DEBUG) {
      let r1; // long order
      let r2; // short order

      try {
        r1 = await exLong.createLimitBuyOrder(pairName, volumeLong, limPriceLong);
        r2 = await exShort.createMarginLimitSellOrder(
          pairName,
          volumeShort,
          limPriceShort
        );
      } catch (e) {
        r1 && exLong.cancelOrder(r1.id, pairName);
        r2 && exShort.cancelOrder(r2.id, pairName);
        logger.info(`Can't place entry order on ${exLong.id}, ${exShort.id}, try cancel it.`);
        throw e;
      }

      // Loops until both orders are completed
      do {
        try {
          r1 = await exLong.fetchOrder(r1.id, pairName);
          r2 = await exShort.fetchOrder(r2.id, pairName);
          logger.info(`Order on ${exLong.id}, ${exShort.id}, still open...`);
        } catch (e) {
          logger.error(`Error with order completed loop ${e.message}`);
        }
      } while (r1.status === "open" && r2.status === "open");
    }

    logger.inout(`Create limit buy order for long exchange in demo mode: [${pairName}, ${volumeLong}, ${limPriceLong}]`);
    logger.inout(`Create margin limit sell order for short exchange in demo mode: [${pairName}, ${volumeShort}, ${limPriceShort}]`);

    return entryInfo;
  }
}

module.exports = Entry;
