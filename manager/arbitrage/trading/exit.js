/**
 * @since 03.01.2018
 * @author Skurishin Vladislav
 */
const moment = require("moment");
const TradingUtils = require("../utils.js");
const Spread = require("../../../models/spread");
const History = require("../../../models/history");
const TrailingManager = require("./trailing");
const logger = require("../../../utils/telegraf")(module);

class Exit {
  /**
   * Check market on exit. If spread <= exitTarget, then exit market.
   * @param entryInfo info about market entry
   */
  static async check (entryInfo) {
    const {exShort, exLong, exitTarget, pairName} = entryInfo;
    const tShort = exShort.tickers[pairName];
    const tLong = exLong.tickers[pairName];
    const bid = tLong.bid;
    const ask = tShort.ask;

    if (!ask && !bid) {
      return false;
    }

    const spread = (ask - bid) / bid;

    logger.info(`[${exShort.id} - ${exLong.id}] spread exit for ${pairName}: ${spread}`);

    if (TradingUtils.STATISTICS) {
      await Spread.create({
        spread,
        exShort,
        exLong,
        pairName
      });
      await History.create({
        spread,
        exShort,
        exLong,
        pairName
      });
      return false;
    }

    if (spread < 0) {
      logger.path(`Negative spread for [${exShort.id} - ${exLong.id}] and pair ${pairName}: ${spread.toFixed(
        4)}.`);
    }

    if (TrailingManager.exit({
        shortId: exShort.id,
        longId:  exLong.id,
        spread,
        exitTarget,
        pairName
      })) {
      return Object.assign(entryInfo, {
        priceLongOut:  ask,
        priceShortOut: bid
      });
    }
  }

  /**
   * Start market exit.
   * @return {Promise.<boolean>}
   * @param exitInfo exit info
   */
  static async start (exitInfo) {
    const {exLong, exShort, priceLongOut, pairName, priceShortOut} = exitInfo;

    // Checks the volumes and computes the limit prices that will be sent to the exchanges
    const volumeLong = exitInfo.volumeLong;
    const volumeShort = exitInfo.volumeShort;

    const limPriceLong = await TradingUtils.getLimitPrice(exLong, volumeLong, "bids", pairName);
    const limPriceShort = await TradingUtils.getLimitPrice(exShort, volumeShort, "asks", pairName);

    if (!limPriceLong || !limPriceShort) {
      logger.warn(
        "Opportunity found, but error with the order books (limit price is null). Trade canceled.");
      return false;
    }

    // The maximum difference between the target
    // limit price and the computed limit price of an order.
    // That is the price generated by looking at the current liquidity in
    // the order books. If the difference is greater than liquidityDelta}
    // then no trades will be generated because there is not enough
    // liquidity (risk of slippage)
    if (priceLongOut - limPriceLong > TradingUtils.LIQUIDITY_DELTA
        || limPriceShort - priceShortOut > TradingUtils.LIQUIDITY_DELTA) {
      logger.warn("Opportunity found, but not enough liquidity. Trade canceled.");
      return false;
    }

    exitInfo.exitTime = moment();
    exitInfo.priceLongOut = limPriceLong;
    exitInfo.priceShortOut = limPriceShort;

    // TODO needs a limits check.
    // If limit > volume then exception occurs
    // and short exchange doesn't place order.
    if (!TradingUtils.DEBUG) {
      let r1; // long order
      let r2; // short order

      try {
        r1 = await exLong.createLimitSellOrder(pairName, volumeLong, limPriceLong);
        r2 = await exShort.createMarginLimitBuyOrder(
          pairName,
          volumeShort,
          limPriceShort
        );
      } catch (e) {
        r1 && exLong.cancelOrder(r1.id, pairName);
        r2 && exShort.cancelOrder(r2.id, pairName);
        logger.info(`Can't place exit order on ${exLong.id}, ${exShort.id}, try cancel it.`);
        throw e;
      }

      // Loops until both orders are completed
      do {
        try {
          r1 = await exLong.fetchOrder(r1.id, pairName);
          r2 = await exShort.fetchOrder(r2.id, pairName);
          logger.info(`Order on ${exLong.id}, ${exShort.id}, still open...`);
        } catch (e) {
          logger.error(`Error with order completed loop ${e.message}`);
        }
      } while (r1.status === "open" && r2.status === "open");
    }

    logger.inout(`Create limit sell order for long exchange in demo mode: [${pairName}, ${volumeLong}, ${limPriceLong}]`);
    logger.inout(`Create margin limit buy order for short exchange in demo mode: [${pairName}, ${volumeShort}, ${limPriceShort}]`);

    return exitInfo;
  }
}

module.exports = Exit;
